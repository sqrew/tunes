use super::TrackBuilder;

impl<'a> TrackBuilder<'a> {
    /// Add a sequence of chords with equal duration starting at the current cursor position
    pub fn chords(mut self, chord_sequence: &[&[f32]], chord_duration: f32) -> Self {
        for chord in chord_sequence {
            self.track.add_note_with_waveform_envelope_and_bend(
                chord,
                self.cursor,
                chord_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(chord_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Add a sequence of chords from Vec format (e.g. from progression()) with equal duration
    ///
    /// This is a convenience method for playing chord progressions generated by theory::progression()
    /// which returns Vec<Vec<f32>> instead of &[&[f32]].
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::theory::{progression, ScalePattern, ProgressionType};
    /// use tunes::notes::C4;
    ///
    /// let pop_prog = progression(C4, &ScalePattern::MAJOR, &[1, 5, 6, 4], ProgressionType::Triads);
    /// comp.instrument("chords", &Instrument::warm_pad())
    ///     .chords_from(&pop_prog, 1.5);  // I-V-vi-IV progression
    /// ```
    pub fn chords_from(mut self, chord_vecs: &[Vec<f32>], chord_duration: f32) -> Self {
        for chord in chord_vecs {
            self.track.add_note_with_waveform_envelope_and_bend(
                chord.as_slice(),
                self.cursor,
                chord_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(chord_duration);
            self.cursor += swung_duration;
        }
        self
    }
    /// Play a scale upward (ascending)
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale(&C4_MAJOR_SCALE, 0.1);  // Plays C4, D4, E4, F4, G4, A4, B4, C5
    /// ```
    pub fn scale(self, scale: &[f32], note_duration: f32) -> Self {
        self.notes(scale, note_duration)
    }

    /// Play a scale downward (descending)
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale_reverse(&C4_MAJOR_SCALE, 0.1);  // Plays C5, B4, A4, G4, F4, E4, D4, C4
    /// ```
    pub fn scale_reverse(mut self, scale: &[f32], note_duration: f32) -> Self {
        // Play the scale in reverse order
        for &freq in scale.iter().rev() {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Play a scale up then down without doubling the peak note
    ///
    /// Unlike calling scale() then scale_reverse(), this avoids repeating
    /// the highest note, creating a smooth melodic contour.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale_updown(&C4_MAJOR_SCALE, 0.1);  // Plays C4, D4, E4, F4, G4, F4, E4, D4, C4
    /// ```
    pub fn scale_updown(mut self, scale: &[f32], note_duration: f32) -> Self {
        if scale.is_empty() {
            return self;
        }

        // Play ascending
        for &freq in scale.iter() {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play descending, skipping the first note (which was the peak)
        for &freq in scale.iter().rev().skip(1) {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play a scale down then up without doubling the bottom note
    ///
    /// The reverse of scale_updown(), starting from the top and avoiding
    /// repetition at the bottom.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale_downup(&C4_MAJOR_SCALE, 0.1);  // Plays G4, F4, E4, D4, C4, D4, E4, F4, G4
    /// ```
    pub fn scale_downup(mut self, scale: &[f32], note_duration: f32) -> Self {
        if scale.is_empty() {
            return self;
        }

        // Play descending
        for &freq in scale.iter().rev() {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play ascending, skipping the first note (which was the bottom)
        for &freq in scale.iter().skip(1) {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play a chord as an ascending arpeggio
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate(C4_MAJOR, 0.125);  // Plays C4, E4, G4 sequentially
    /// ```
    pub fn arpeggiate(self, chord: &[f32], note_duration: f32) -> Self {
        self.notes(chord, note_duration)
    }

    /// Play a chord as a descending arpeggio
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate_reverse(C4_MAJOR, 0.125);  // Plays G4, E4, C4 sequentially
    /// ```
    pub fn arpeggiate_reverse(mut self, chord: &[f32], note_duration: f32) -> Self {
        // Play the chord notes in reverse order
        for &freq in chord.iter().rev() {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Play an arpeggio up then down without doubling the top note
    ///
    /// Unlike calling arpeggiate() then arpeggiate_reverse(), this avoids
    /// repeating the highest note, creating a smoother arpeggio pattern.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate_updown(C4_MAJOR, 0.125);  // Plays C4, E4, G4, E4, C4 (no double G4)
    /// ```
    pub fn arpeggiate_updown(mut self, chord: &[f32], note_duration: f32) -> Self {
        if chord.is_empty() {
            return self;
        }

        // Play ascending
        for &freq in chord.iter() {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play descending, skipping the first note (which was the top)
        for &freq in chord.iter().rev().skip(1) {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play an arpeggio down then up without doubling the bottom note
    ///
    /// The reverse of arpeggiate_updown(), starting from the top and avoiding
    /// repetition at the bottom.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate_downup(C4_MAJOR, 0.125);  // Plays G4, E4, C4, E4, G4 (no double C4)
    /// ```
    pub fn arpeggiate_downup(mut self, chord: &[f32], note_duration: f32) -> Self {
        if chord.is_empty() {
            return self;
        }

        // Play descending
        for &freq in chord.iter().rev() {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play ascending, skipping the first note (which was the bottom)
        for &freq in chord.iter().skip(1) {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play notes with octave doubling
    ///
    /// Each note is played simultaneously with a copy shifted by the specified number of octaves.
    /// Positive values double above, negative values double below.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// comp.instrument("thicc", &Instrument::saw_lead())
    ///     .octaves(&[C4, D4, E4], -1, 0.25);  // Each note plays with octave below
    ///     // Plays: C4+C3, D4+D3, E4+E3
    /// ```
    pub fn octaves(mut self, notes: &[f32], octave_offset: i32, note_duration: f32) -> Self {
        let multiplier = 2.0f32.powi(octave_offset);

        for &freq in notes {
            let doubled_freq = freq * multiplier;
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq, doubled_freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Play notes with harmonic interval doubling
    ///
    /// Each note is played simultaneously with a copy shifted by the specified number of semitones.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// comp.instrument("harmony", &Instrument::pluck())
    ///     .harmonize(&[C4, D4, E4], 7, 0.25);  // Add perfect fifth (7 semitones) above
    ///     // Plays: C4+G4, D4+A4, E4+B4
    pub fn harmonize(mut self, notes: &[f32], semitones: i32, note_duration: f32) -> Self {
        let multiplier = 2.0f32.powf(semitones as f32 / 12.0);

        for &freq in notes {
            let harmony_freq = freq * multiplier;
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq, harmony_freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Guitar strum effect - quick cascade
    ///
    /// Similar to cascade but optimized for very short stagger times (guitar strum feel).
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # use tunes::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::chords::C4_MAJOR;
    /// comp.instrument("guitar", &Instrument::pluck())
    ///     .strum(C4_MAJOR, 0.5, 0.02);  // Quick upstroke (20ms between strings)
    pub fn pedal(mut self, pedal_note: f32, melody_notes: &[f32], note_duration: f32) -> Self {
        let start_cursor = self.cursor;
        let total_melody_duration = melody_notes.len() as f32 * note_duration;

        // Add sustained pedal note
        self.track.add_note_with_waveform_envelope_and_bend(
            &[pedal_note],
            start_cursor,
            total_melody_duration,
            self.waveform,
            self.envelope,
            self.pitch_bend,
        );

        // Add melody notes on top
        for &freq in melody_notes {
            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Generate notes from a mathematical sequence mapped to a scale
    ///
    /// Takes a mathematical sequence (Fibonacci, primes, etc.) and maps each value
    /// to notes from a scale/chord by using the sequence values as indices (modulo scale length).
    ///
    /// # Arguments
    /// * `sequence` - The mathematical sequence values
    /// * `notes` - Scale or chord to map sequence indices to
    /// * `note_duration` - Duration for each note
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::sequences;
    /// use tunes::scales::C4_MAJOR_SCALE;
    ///
    /// let fib = sequences::fibonacci(16);
    /// comp.instrument("fib", &Instrument::pluck())
    ///     .sequence_from(&fib, &C4_MAJOR_SCALE, 0.125);  // Maps Fibonacci to C major scale
    ///
    /// // Fibonacci: 1,1,2,3,5,8,13,21...
    /// // Plays: D4, D4, E4, F4, A4, C5, A4, E4... (wrapping around the scale)
    pub fn sequence_from(mut self, sequence: &[u32], notes: &[f32], note_duration: f32) -> Self {
        for &value in sequence {
            // Map sequence value to note index (wrapping around if needed)
            let note_index = (value as usize) % notes.len();
            let freq = notes[note_index];

            self.track.add_note_with_waveform_envelope_and_bend(
                &[freq],
                self.cursor,
                note_duration,
                self.waveform,
                self.envelope,
                self.pitch_bend,
            );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

}

#[cfg(test)]
mod tests {
    use crate::composition::Composition;
    use crate::notes::*;
    use crate::rhythm::Tempo;
    use crate::track::AudioEvent;

    #[test]
    fn test_chords_plays_sequence() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chords: Vec<&[f32]> = vec![&[C4, E4, G4], &[F4, A4, C5]];
        comp.track("chords").chords(&chords, 1.0);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 2);

        // First chord
        if let AudioEvent::Note(note) = track.events[0] {
            assert_eq!(note.num_freqs, 3);
            assert_eq!(note.start_time, 0.0);
            assert_eq!(note.duration, 1.0);
        }

        // Second chord
        if let AudioEvent::Note(note) = track.events[1] {
            assert_eq!(note.num_freqs, 3);
            assert_eq!(note.start_time, 1.0);
        }
    }

    #[test]
    fn test_chords_from_vec_format() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chords = vec![vec![C4, E4, G4], vec![F4, A4, C5]];
        comp.track("chords").chords_from(&chords, 0.5);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 2);
    }

    #[test]
    fn test_scale_ascending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4, F4, G4];
        comp.track("scale").scale(&scale, 0.2);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 5);

        // Verify ascending order
        for (i, &expected) in scale.iter().enumerate() {
            if let AudioEvent::Note(note) = track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_scale_reverse_descending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4, F4, G4];
        comp.track("scale").scale_reverse(&scale, 0.2);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 5);

        // Verify descending order (reversed)
        for (i, &expected) in scale.iter().rev().enumerate() {
            if let AudioEvent::Note(note) = track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_scale_updown_no_peak_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4];
        comp.track("scale").scale_updown(&scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: C4, D4, E4 (up), then D4, C4 (down, skipping E4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = track.events[2] {
            assert_eq!(note.frequencies[0], E4); // Peak
        }
        if let AudioEvent::Note(note) = track.events[3] {
            assert_eq!(note.frequencies[0], D4); // First note going down
        }
    }

    #[test]
    fn test_scale_updown_with_empty_scale() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let builder = comp.track("scale").scale_updown(&[], 0.1);

        assert_eq!(builder.cursor, 0.0);
    }

    #[test]
    fn test_scale_downup_no_bottom_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4];
        comp.track("scale").scale_downup(&scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: E4, D4, C4 (down), then D4, E4 (up, skipping C4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = track.events[2] {
            assert_eq!(note.frequencies[0], C4); // Bottom
        }
        if let AudioEvent::Note(note) = track.events[3] {
            assert_eq!(note.frequencies[0], D4); // First note going up
        }
    }

    #[test]
    fn test_arpeggiate_ascending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate(&chord, 0.125);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);

        // Verify ascending order
        for (i, &expected) in chord.iter().enumerate() {
            if let AudioEvent::Note(note) = track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_arpeggiate_reverse_descending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate_reverse(&chord, 0.125);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);

        // Verify descending order
        for (i, &expected) in chord.iter().rev().enumerate() {
            if let AudioEvent::Note(note) = track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_arpeggiate_updown_no_top_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate_updown(&chord, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: C4, E4, G4 (up), then E4, C4 (down, skipping G4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = track.events[2] {
            assert_eq!(note.frequencies[0], G4); // Top
        }
        if let AudioEvent::Note(note) = track.events[3] {
            assert_eq!(note.frequencies[0], E4); // First note going down
        }
    }

    #[test]
    fn test_arpeggiate_downup_no_bottom_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate_downup(&chord, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: G4, E4, C4 (down), then E4, G4 (up, skipping C4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = track.events[2] {
            assert_eq!(note.frequencies[0], C4); // Bottom
        }
        if let AudioEvent::Note(note) = track.events[3] {
            assert_eq!(note.frequencies[0], E4); // First note going up
        }
    }

    #[test]
    fn test_octaves_doubles_each_note() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("thick").octaves(&[C4, E4], 1, 0.5); // Octave above

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 2);

        // First note should have 2 frequencies (C4 + C5)
        if let AudioEvent::Note(note) = track.events[0] {
            assert_eq!(note.num_freqs, 2);
            assert_eq!(note.frequencies[0], C4);
            // Octave above should be 2x frequency
            assert!((note.frequencies[1] - C4 * 2.0).abs() < 0.1);
        }
    }

    #[test]
    fn test_octaves_negative_offset() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("thick").octaves(&[C4], -1, 0.5); // Octave below

        let track = &comp.into_mixer().tracks[0];

        if let AudioEvent::Note(note) = track.events[0] {
            assert_eq!(note.num_freqs, 2);
            assert_eq!(note.frequencies[0], C4);
            // Octave below should be 0.5x frequency
            assert!((note.frequencies[1] - C4 * 0.5).abs() < 0.1);
        }
    }

    #[test]
    fn test_harmonize_adds_interval() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("harmony").harmonize(&[C4], 7, 0.5); // Perfect fifth (7 semitones)

        let track = &comp.into_mixer().tracks[0];

        if let AudioEvent::Note(note) = track.events[0] {
            assert_eq!(note.num_freqs, 2);
            assert_eq!(note.frequencies[0], C4);
            // G4 is 7 semitones above C4
            let expected_g4 = C4 * 2.0f32.powf(7.0 / 12.0);
            assert!((note.frequencies[1] - expected_g4).abs() < 0.1);
        }
    }

    #[test]
    fn test_harmonize_multiple_notes() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("harmony").harmonize(&[C4, D4, E4], 4, 0.25); // Major third

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);

        // Each note should be doubled with harmony
        for event in &track.events {
            if let AudioEvent::Note(note) = event {
                assert_eq!(note.num_freqs, 2);
            }
        }
    }

    #[test]
    fn test_pedal_sustains_bass() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("pedal").pedal(C4, &[E4, G4, B4], 0.5);

        let track = &comp.into_mixer().tracks[0];
        // Should have 1 pedal note + 3 melody notes = 4 events
        assert_eq!(track.events.len(), 4);

        // First note should be the long pedal note
        if let AudioEvent::Note(pedal) = track.events[0] {
            assert_eq!(pedal.frequencies[0], C4);
            assert_eq!(pedal.duration, 1.5); // 3 notes * 0.5
            assert_eq!(pedal.start_time, 0.0);
        }

        // Melody notes should follow
        if let AudioEvent::Note(note) = track.events[1] {
            assert_eq!(note.frequencies[0], E4);
            assert_eq!(note.start_time, 0.0);
        }
        if let AudioEvent::Note(note) = track.events[2] {
            assert_eq!(note.frequencies[0], G4);
            assert_eq!(note.start_time, 0.5);
        }
    }

    #[test]
    fn test_pedal_advances_cursor_correctly() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let builder = comp.track("pedal").pedal(C4, &[E4, G4], 0.5);

        // 2 melody notes * 0.5 = 1.0
        assert_eq!(builder.cursor, 1.0);
    }

    #[test]
    fn test_sequence_from_maps_values() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let sequence = [0, 1, 2, 3, 4];
        let scale = [C4, D4, E4, F4, G4];
        comp.track("seq").sequence_from(&sequence, &scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 5);

        // Should map directly: sequence[i] -> scale[i]
        for (i, &seq_val) in sequence.iter().enumerate() {
            if let AudioEvent::Note(note) = track.events[i] {
                assert_eq!(note.frequencies[0], scale[seq_val as usize]);
            }
        }
    }

    #[test]
    fn test_sequence_from_wraps_around() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let sequence = [0, 3, 6, 9]; // Larger than scale length
        let scale = [C4, D4, E4]; // Length 3
        comp.track("seq").sequence_from(&sequence, &scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 4);

        // Values should wrap: 0->C4, 3->C4, 6->C4, 9->C4
        for event in &track.events {
            if let AudioEvent::Note(note) = event {
                assert_eq!(note.frequencies[0], C4);
            }
        }
    }

    #[test]
    fn test_sequence_from_fibonacci_pattern() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let fib = [1, 1, 2, 3, 5, 8];
        let scale = [C4, D4, E4, F4, G4];
        comp.track("fib").sequence_from(&fib, &scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 6);

        // Verify mapping: 1->D4, 1->D4, 2->E4, 3->F4, 5->C4(wrapped), 8->F4(wrapped)
        let expected = [D4, D4, E4, F4, C4, F4];
        for (i, &exp) in expected.iter().enumerate() {
            if let AudioEvent::Note(note) = track.events[i] {
                assert_eq!(note.frequencies[0], exp);
            }
        }
    }

    #[test]
    fn test_chaining_musical_patterns() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("combo")
            .scale(&[C4, D4, E4], 0.1)
            .arpeggiate(&[C4, E4, G4], 0.1)
            .scale_reverse(&[C4, D4, E4], 0.1);

        let track = &comp.into_mixer().tracks[0];
        // 3 scale + 3 arp + 3 reverse = 9 total
        assert_eq!(track.events.len(), 9);
    }

    #[test]
    fn test_empty_chord_sequences() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let empty: Vec<&[f32]> = vec![];
        let builder = comp.track("empty").chords(&empty, 1.0);

        assert_eq!(builder.cursor, 0.0);
    }

    #[test]
    fn test_single_note_updown_patterns() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("single").scale_updown(&[C4], 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Single note: up (1 note), down (skip first = 0 notes) = 1 total
        assert_eq!(track.events.len(), 1);
    }
}
