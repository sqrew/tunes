use super::TrackBuilder;

impl<'a> TrackBuilder<'a> {
    /// Add a sequence of chords with equal duration starting at the current cursor position
    pub fn chords(mut self, chord_sequence: &[&[f32]], chord_duration: f32) -> Self {
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        for chord in chord_sequence {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    chord,
                    cursor,
                    chord_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(chord_duration);
            self.cursor += swung_duration;
        }
        self.update_section_duration();
        self
    }

    /// Play a chord progression using scale degrees with triads
    ///
    /// This is a convenient one-liner for creating and playing chord progressions.
    /// Combines `progression()` and `.chords_from()` into a single method call.
    ///
    /// # Arguments
    /// * `root` - The root note frequency (e.g., C4, G3)
    /// * `scale_pattern` - The scale to build chords from (e.g., ScalePattern::MAJOR)
    /// * `degrees` - Scale degrees to play (e.g., &[1, 5, 6, 4] for I-V-vi-IV)
    /// * `chord_duration` - How long to play each chord
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::theory::core::ScalePattern;
    ///
    /// // Play a classic pop progression: I-V-vi-IV in C major
    /// comp.instrument("chords", &Instrument::warm_pad())
    ///     .progression(C4, &ScalePattern::MAJOR, &[1, 5, 6, 4], 1.5);
    /// ```
    pub fn progression(
        self,
        root: f32,
        scale_pattern: &crate::theory::core::ScalePattern,
        degrees: &[usize],
        chord_duration: f32,
    ) -> Self {
        let prog = crate::theory::core::progression(
            root,
            scale_pattern,
            degrees,
            crate::theory::core::ProgressionType::Triads,
        );
        self.chords_from(&prog, chord_duration)
    }

    /// Play a chord progression using scale degrees with 7th chords
    ///
    /// Same as `.progression()` but uses 7th chords instead of triads for a jazzier sound.
    ///
    /// # Arguments
    /// * `root` - The root note frequency (e.g., C4, G3)
    /// * `scale_pattern` - The scale to build chords from (e.g., ScalePattern::MAJOR)
    /// * `degrees` - Scale degrees to play (e.g., &[2, 5, 1] for ii-V-I)
    /// * `chord_duration` - How long to play each chord
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::theory::core::ScalePattern;
    ///
    /// // Play a jazz progression: ii7-V7-Imaj7 in C major
    /// comp.instrument("jazz", &Instrument::electric_piano())
    ///     .progression_7th(C4, &ScalePattern::MAJOR, &[2, 5, 1], 2.0);
    /// ```
    pub fn progression_7th(
        self,
        root: f32,
        scale_pattern: &crate::theory::core::ScalePattern,
        degrees: &[usize],
        chord_duration: f32,
    ) -> Self {
        let prog = crate::theory::core::progression(
            root,
            scale_pattern,
            degrees,
            crate::theory::core::ProgressionType::Sevenths,
        );
        self.chords_from(&prog, chord_duration)
    }

    /// Add a sequence of chords from Vec format (e.g. from progression()) with equal duration
    ///
    /// This is a convenience method for playing chord progressions generated by theory::progression()
    /// which returns Vec<Vec<f32>> instead of &[&[f32]].
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::theory::core::{progression, ScalePattern, ProgressionType};
    /// use tunes::consts::notes::C4;
    ///
    /// let pop_prog = progression(C4, &ScalePattern::MAJOR, &[1, 5, 6, 4], ProgressionType::Triads);
    /// comp.instrument("chords", &Instrument::warm_pad())
    ///     .chords_from(&pop_prog, 1.5);  // I-V-vi-IV progression
    /// ```
    pub fn chords_from(mut self, chord_vecs: &[Vec<f32>], chord_duration: f32) -> Self {
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        for chord in chord_vecs {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    chord.as_slice(),
                    cursor,
                    chord_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(chord_duration);
            self.cursor += swung_duration;
        }
        self.update_section_duration();
        self
    }
    /// Play a scale upward (ascending)
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale(&C4_MAJOR_SCALE, 0.1);  // Plays C4, D4, E4, F4, G4, A4, B4, C5
    /// ```
    pub fn scale(self, scale: &[f32], note_duration: f32) -> Self {
        self.notes(scale, note_duration)
    }

    /// Play a scale downward (descending)
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale_reverse(&C4_MAJOR_SCALE, 0.1);  // Plays C5, B4, A4, G4, F4, E4, D4, C4
    /// ```
    pub fn scale_reverse(mut self, scale: &[f32], note_duration: f32) -> Self {
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Play the scale in reverse order
        for &freq in scale.iter().rev() {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self.update_section_duration();
        self
    }

    /// Play a scale up then down without doubling the peak note
    ///
    /// Unlike calling scale() then scale_reverse(), this avoids repeating
    /// the highest note, creating a smooth melodic contour.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale_updown(&C4_MAJOR_SCALE, 0.1);  // Plays C4, D4, E4, F4, G4, F4, E4, D4, C4
    /// ```
    pub fn scale_updown(mut self, scale: &[f32], note_duration: f32) -> Self {
        if scale.is_empty() {
            return self;
        }

        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Play ascending
        for &freq in scale.iter() {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play descending, skipping the first note (which was the peak)
        for &freq in scale.iter().rev().skip(1) {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self.update_section_duration();
        self
    }

    /// Play a scale down then up without doubling the bottom note
    ///
    /// The reverse of scale_updown(), starting from the top and avoiding
    /// repetition at the bottom.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::scales::C4_MAJOR_SCALE;
    /// comp.instrument("run", &Instrument::pluck())
    ///     .scale_downup(&C4_MAJOR_SCALE, 0.1);  // Plays G4, F4, E4, D4, C4, D4, E4, F4, G4
    /// ```
    pub fn scale_downup(mut self, scale: &[f32], note_duration: f32) -> Self {
        if scale.is_empty() {
            return self;
        }

        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Play descending
        for &freq in scale.iter().rev() {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play ascending, skipping the first note (which was the bottom)
        for &freq in scale.iter().skip(1) {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play a chord as an ascending arpeggio
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate(C4_MAJOR, 0.125);  // Plays C4, E4, G4 sequentially
    /// ```
    pub fn arpeggiate(self, chord: &[f32], note_duration: f32) -> Self {
        self.notes(chord, note_duration)
    }

    /// Play a chord as a descending arpeggio
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate_reverse(C4_MAJOR, 0.125);  // Plays G4, E4, C4 sequentially
    /// ```
    pub fn arpeggiate_reverse(mut self, chord: &[f32], note_duration: f32) -> Self {
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Play the chord notes in reverse order
        for &freq in chord.iter().rev() {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Play an arpeggio up then down without doubling the top note
    ///
    /// Unlike calling arpeggiate() then arpeggiate_reverse(), this avoids
    /// repeating the highest note, creating a smoother arpeggio pattern.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate_updown(C4_MAJOR, 0.125);  // Plays C4, E4, G4, E4, C4 (no double G4)
    /// ```
    pub fn arpeggiate_updown(mut self, chord: &[f32], note_duration: f32) -> Self {
        if chord.is_empty() {
            return self;
        }

        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Play ascending
        for &freq in chord.iter() {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play descending, skipping the first note (which was the top)
        for &freq in chord.iter().rev().skip(1) {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play an arpeggio down then up without doubling the bottom note
    ///
    /// The reverse of arpeggiate_updown(), starting from the top and avoiding
    /// repetition at the bottom.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::consts::chords::C4_MAJOR;
    /// comp.instrument("arp", &Instrument::pluck())
    ///     .arpeggiate_downup(C4_MAJOR, 0.125);  // Plays G4, E4, C4, E4, G4 (no double C4)
    /// ```
    pub fn arpeggiate_downup(mut self, chord: &[f32], note_duration: f32) -> Self {
        if chord.is_empty() {
            return self;
        }

        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Play descending
        for &freq in chord.iter().rev() {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        // Play ascending, skipping the first note (which was the bottom)
        for &freq in chord.iter().skip(1) {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Play notes with octave doubling
    ///
    /// Each note is played simultaneously with a copy shifted by the specified number of octaves.
    /// Positive values double above, negative values double below.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// comp.instrument("thicc", &Instrument::saw_lead())
    ///     .octaves(&[C4, D4, E4], -1, 0.25);  // Each note plays with octave below
    ///     // Plays: C4+C3, D4+D3, E4+E3
    /// ```
    pub fn octaves(mut self, notes: &[f32], octave_offset: i32, note_duration: f32) -> Self {
        let multiplier = 2.0f32.powi(octave_offset);
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        for &freq in notes {
            let doubled_freq = freq * multiplier;
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq, doubled_freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Play notes with harmonic interval doubling
    ///
    /// Each note is played simultaneously with a copy shifted by the specified number of semitones.
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// comp.instrument("harmony", &Instrument::pluck())
    ///     .harmonize(&[C4, D4, E4], 7, 0.25);  // Add perfect fifth (7 semitones) above
    ///     // Plays: C4+G4, D4+A4, E4+B4
    pub fn harmonize(mut self, notes: &[f32], semitones: i32, note_duration: f32) -> Self {
        let multiplier = 2.0f32.powf(semitones as f32 / 12.0);
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        for &freq in notes {
            let harmony_freq = freq * multiplier;
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq, harmony_freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }

    /// Pedal point - sustained note with melody above
    ///
    /// Adds a sustained bass note (pedal point) while playing a melody on top.
    /// Common in organ music, drone-based music, and creating harmonic tension.
    ///
    /// # Arguments
    /// * `pedal_note` - The sustained bass note frequency
    /// * `melody_notes` - Notes to play above the pedal point
    /// * `note_duration` - Duration of each melody note
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # use tunes::consts::notes::*;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// comp.instrument("organ", &Instrument::warm_pad())
    ///     .pedal(C2, &[E4, F4, G4, A4], 0.5);  // C pedal with melody above
    /// ```
    pub fn pedal(mut self, pedal_note: f32, melody_notes: &[f32], note_duration: f32) -> Self {
        let start_cursor = self.cursor;
        let total_melody_duration = melody_notes.len() as f32 * note_duration;
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        // Add sustained pedal note
        self.get_track_mut()
            .add_note_with_waveform_envelope_and_bend(
                &[pedal_note],
                start_cursor,
                total_melody_duration,
                waveform,
                envelope,
                pitch_bend,
            );

        // Add melody notes on top
        for &freq in melody_notes {
            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }

        self
    }

    /// Generate notes from a mathematical sequence mapped to a scale
    ///
    /// Takes a mathematical sequence (Fibonacci, primes, etc.) and maps each value
    /// to notes from a scale/chord by using the sequence values as indices (modulo scale length).
    ///
    /// # Arguments
    /// * `sequence` - The mathematical sequence values
    /// * `notes` - Scale or chord to map sequence indices to
    /// * `note_duration` - Duration for each note
    ///
    /// # Example
    /// ```
    /// # use tunes::composition::Composition;
    /// # use tunes::instruments::Instrument;
    /// # use tunes::composition::rhythm::Tempo;
    /// # let mut comp = Composition::new(Tempo::new(120.0));
    /// use tunes::sequences;
    /// use tunes::consts::scales::C4_MAJOR_SCALE;
    ///
    /// let fib = sequences::fibonacci(16);
    /// comp.instrument("fib", &Instrument::pluck())
    ///     .sequence_from(&fib, &C4_MAJOR_SCALE, 0.125);  // Maps Fibonacci to C major scale
    ///
    /// // Fibonacci: 1,1,2,3,5,8,13,21...
    /// // Plays: D4, D4, E4, F4, A4, C5, A4, E4... (wrapping around the scale)
    pub fn sequence_from(mut self, sequence: &[u32], notes: &[f32], note_duration: f32) -> Self {
        let waveform = self.waveform;
        let envelope = self.envelope;
        let pitch_bend = self.pitch_bend;

        for &value in sequence {
            // Map sequence value to note index (wrapping around if needed)
            let note_index = (value as usize) % notes.len();
            let freq = notes[note_index];

            let cursor = self.cursor;
            self.get_track_mut()
                .add_note_with_waveform_envelope_and_bend(
                    &[freq],
                    cursor,
                    note_duration,
                    waveform,
                    envelope,
                    pitch_bend,
                );
            let swung_duration = self.apply_swing(note_duration);
            self.cursor += swung_duration;
        }
        self
    }
}

#[cfg(test)]
mod tests {
    use crate::composition::Composition;
    use crate::consts::notes::*;
    use crate::composition::rhythm::Tempo;
    use crate::track::AudioEvent;

    #[test]
    fn test_chords_plays_sequence() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chords: Vec<&[f32]> = vec![&[C4, E4, G4], &[F4, A4, C5]];
        comp.track("chords").chords(&chords, 1.0);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 2);

        // First chord
        if let AudioEvent::Note(note) = &track.events[0] {
            assert_eq!(note.num_freqs, 3);
            assert_eq!(note.start_time, 0.0);
            assert_eq!(note.duration, 1.0);
        }

        // Second chord
        if let AudioEvent::Note(note) = &track.events[1] {
            assert_eq!(note.num_freqs, 3);
            assert_eq!(note.start_time, 1.0);
        }
    }

    #[test]
    fn test_chords_from_vec_format() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chords = vec![vec![C4, E4, G4], vec![F4, A4, C5]];
        comp.track("chords").chords_from(&chords, 0.5);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 2);
    }

    #[test]
    fn test_scale_ascending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4, F4, G4];
        comp.track("scale").scale(&scale, 0.2);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 5);

        // Verify ascending order
        for (i, &expected) in scale.iter().enumerate() {
            if let AudioEvent::Note(note) = &track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_scale_reverse_descending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4, F4, G4];
        comp.track("scale").scale_reverse(&scale, 0.2);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 5);

        // Verify descending order (reversed)
        for (i, &expected) in scale.iter().rev().enumerate() {
            if let AudioEvent::Note(note) = &track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_scale_updown_no_peak_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4];
        comp.track("scale").scale_updown(&scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: C4, D4, E4 (up), then D4, C4 (down, skipping E4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = &track.events[2] {
            assert_eq!(note.frequencies[0], E4); // Peak
        }
        if let AudioEvent::Note(note) = &track.events[3] {
            assert_eq!(note.frequencies[0], D4); // First note going down
        }
    }

    #[test]
    fn test_scale_updown_with_empty_scale() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let builder = comp.track("scale").scale_updown(&[], 0.1);

        assert_eq!(builder.cursor, 0.0);
    }

    #[test]
    fn test_scale_downup_no_bottom_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let scale = [C4, D4, E4];
        comp.track("scale").scale_downup(&scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: E4, D4, C4 (down), then D4, E4 (up, skipping C4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = &track.events[2] {
            assert_eq!(note.frequencies[0], C4); // Bottom
        }
        if let AudioEvent::Note(note) = &track.events[3] {
            assert_eq!(note.frequencies[0], D4); // First note going up
        }
    }

    #[test]
    fn test_arpeggiate_ascending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate(&chord, 0.125);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);

        // Verify ascending order
        for (i, &expected) in chord.iter().enumerate() {
            if let AudioEvent::Note(note) = &track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_arpeggiate_reverse_descending() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate_reverse(&chord, 0.125);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);

        // Verify descending order
        for (i, &expected) in chord.iter().rev().enumerate() {
            if let AudioEvent::Note(note) = &track.events[i] {
                assert_eq!(note.frequencies[0], expected);
            }
        }
    }

    #[test]
    fn test_arpeggiate_updown_no_top_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate_updown(&chord, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: C4, E4, G4 (up), then E4, C4 (down, skipping G4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = &track.events[2] {
            assert_eq!(note.frequencies[0], G4); // Top
        }
        if let AudioEvent::Note(note) = &track.events[3] {
            assert_eq!(note.frequencies[0], E4); // First note going down
        }
    }

    #[test]
    fn test_arpeggiate_downup_no_bottom_double() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let chord = [C4, E4, G4];
        comp.track("arp").arpeggiate_downup(&chord, 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Should be: G4, E4, C4 (down), then E4, G4 (up, skipping C4)
        // Total = 5 notes
        assert_eq!(track.events.len(), 5);

        if let AudioEvent::Note(note) = &track.events[2] {
            assert_eq!(note.frequencies[0], C4); // Bottom
        }
        if let AudioEvent::Note(note) = &track.events[3] {
            assert_eq!(note.frequencies[0], E4); // First note going up
        }
    }

    #[test]
    fn test_octaves_doubles_each_note() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("thick").octaves(&[C4, E4], 1, 0.5); // Octave above

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 2);

        // First note should have 2 frequencies (C4 + C5)
        if let AudioEvent::Note(note) = &track.events[0] {
            assert_eq!(note.num_freqs, 2);
            assert_eq!(note.frequencies[0], C4);
            // Octave above should be 2x frequency
            assert!((note.frequencies[1] - C4 * 2.0).abs() < 0.1);
        }
    }

    #[test]
    fn test_octaves_negative_offset() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("thick").octaves(&[C4], -1, 0.5); // Octave below

        let track = &comp.into_mixer().tracks[0];

        if let AudioEvent::Note(note) = &track.events[0] {
            assert_eq!(note.num_freqs, 2);
            assert_eq!(note.frequencies[0], C4);
            // Octave below should be 0.5x frequency
            assert!((note.frequencies[1] - C4 * 0.5).abs() < 0.1);
        }
    }

    #[test]
    fn test_harmonize_adds_interval() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("harmony").harmonize(&[C4], 7, 0.5); // Perfect fifth (7 semitones)

        let track = &comp.into_mixer().tracks[0];

        if let AudioEvent::Note(note) = &track.events[0] {
            assert_eq!(note.num_freqs, 2);
            assert_eq!(note.frequencies[0], C4);
            // G4 is 7 semitones above C4
            let expected_g4 = C4 * 2.0f32.powf(7.0 / 12.0);
            assert!((note.frequencies[1] - expected_g4).abs() < 0.1);
        }
    }

    #[test]
    fn test_harmonize_multiple_notes() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("harmony").harmonize(&[C4, D4, E4], 4, 0.25); // Major third

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);

        // Each note should be doubled with harmony
        for event in &track.events {
            if let AudioEvent::Note(note) = event {
                assert_eq!(note.num_freqs, 2);
            }
        }
    }

    #[test]
    fn test_pedal_sustains_bass() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("pedal").pedal(C4, &[E4, G4, B4], 0.5);

        let track = &comp.into_mixer().tracks[0];
        // Should have 1 pedal note + 3 melody notes = 4 events
        assert_eq!(track.events.len(), 4);

        // First note should be the long pedal note
        if let AudioEvent::Note(pedal) = &track.events[0] {
            assert_eq!(pedal.frequencies[0], C4);
            assert_eq!(pedal.duration, 1.5); // 3 notes * 0.5
            assert_eq!(pedal.start_time, 0.0);
        }

        // Melody notes should follow
        if let AudioEvent::Note(note) = &track.events[1] {
            assert_eq!(note.frequencies[0], E4);
            assert_eq!(note.start_time, 0.0);
        }
        if let AudioEvent::Note(note) = &track.events[2] {
            assert_eq!(note.frequencies[0], G4);
            assert_eq!(note.start_time, 0.5);
        }
    }

    #[test]
    fn test_pedal_advances_cursor_correctly() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let builder = comp.track("pedal").pedal(C4, &[E4, G4], 0.5);

        // 2 melody notes * 0.5 = 1.0
        assert_eq!(builder.cursor, 1.0);
    }

    #[test]
    fn test_sequence_from_maps_values() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let sequence = [0, 1, 2, 3, 4];
        let scale = [C4, D4, E4, F4, G4];
        comp.track("seq").sequence_from(&sequence, &scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 5);

        // Should map directly: sequence[i] -> scale[i]
        for (i, &seq_val) in sequence.iter().enumerate() {
            if let AudioEvent::Note(note) = &track.events[i] {
                assert_eq!(note.frequencies[0], scale[seq_val as usize]);
            }
        }
    }

    #[test]
    fn test_sequence_from_wraps_around() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let sequence = [0, 3, 6, 9]; // Larger than scale length
        let scale = [C4, D4, E4]; // Length 3
        comp.track("seq").sequence_from(&sequence, &scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 4);

        // Values should wrap: 0->C4, 3->C4, 6->C4, 9->C4
        for event in &track.events {
            if let AudioEvent::Note(note) = event {
                assert_eq!(note.frequencies[0], C4);
            }
        }
    }

    #[test]
    fn test_sequence_from_fibonacci_pattern() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let fib = [1, 1, 2, 3, 5, 8];
        let scale = [C4, D4, E4, F4, G4];
        comp.track("fib").sequence_from(&fib, &scale, 0.1);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 6);

        // Verify mapping: 1->D4, 1->D4, 2->E4, 3->F4, 5->C4(wrapped), 8->F4(wrapped)
        let expected = [D4, D4, E4, F4, C4, F4];
        for (i, &exp) in expected.iter().enumerate() {
            if let AudioEvent::Note(note) = &track.events[i] {
                assert_eq!(note.frequencies[0], exp);
            }
        }
    }

    #[test]
    fn test_chaining_musical_patterns() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("combo")
            .scale(&[C4, D4, E4], 0.1)
            .arpeggiate(&[C4, E4, G4], 0.1)
            .scale_reverse(&[C4, D4, E4], 0.1);

        let track = &comp.into_mixer().tracks[0];
        // 3 scale + 3 arp + 3 reverse = 9 total
        assert_eq!(track.events.len(), 9);
    }

    #[test]
    fn test_empty_chord_sequences() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let empty: Vec<&[f32]> = vec![];
        let builder = comp.track("empty").chords(&empty, 1.0);

        assert_eq!(builder.cursor, 0.0);
    }

    #[test]
    fn test_single_note_updown_patterns() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("single").scale_updown(&[C4], 0.1);

        let track = &comp.into_mixer().tracks[0];
        // Single note: up (1 note), down (skip first = 0 notes) = 1 total
        assert_eq!(track.events.len(), 1);
    }

    #[test]
    fn test_progression_creates_triads() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("prog")
            .progression(C4, &crate::theory::core::ScalePattern::MAJOR, &[1, 4, 5, 1], 1.0);

        let track = &comp.into_mixer().tracks[0];
        // Should have 4 chords (I-IV-V-I)
        assert_eq!(track.events.len(), 4);

        // Each chord should have 3 notes (triads)
        for event in &track.events {
            if let AudioEvent::Note(note) = event {
                assert_eq!(note.num_freqs, 3);
            }
        }
    }

    #[test]
    fn test_progression_7th_creates_seventh_chords() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("jazz").progression_7th(
            C4,
            &crate::theory::core::ScalePattern::MAJOR,
            &[2, 5, 1],
            2.0,
        );

        let track = &comp.into_mixer().tracks[0];
        // Should have 3 chords (ii7-V7-Imaj7)
        assert_eq!(track.events.len(), 3);

        // Each chord should have 4 notes (7th chords)
        for event in &track.events {
            if let AudioEvent::Note(note) = event {
                assert_eq!(note.num_freqs, 4);
            }
        }
    }

    #[test]
    fn test_progression_advances_cursor() {
        let mut comp = Composition::new(Tempo::new(120.0));
        let builder = comp.track("prog").progression(
            C4,
            &crate::theory::core::ScalePattern::MAJOR,
            &[1, 5, 6, 4],
            1.5,
        );

        // 4 chords * 1.5 duration = 6.0
        assert_eq!(builder.cursor, 6.0);
    }

    #[test]
    fn test_progression_with_different_scales() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("minor")
            .progression(A3, &crate::theory::core::ScalePattern::MINOR, &[1, 4, 5], 1.0);

        let track = &comp.into_mixer().tracks[0];
        assert_eq!(track.events.len(), 3);
    }

    #[test]
    fn test_progression_chain_with_other_methods() {
        let mut comp = Composition::new(Tempo::new(120.0));
        comp.track("combo")
            .note(&[C4], 0.5)
            .progression(C4, &crate::theory::core::ScalePattern::MAJOR, &[1, 5], 1.0)
            .note(&[G4], 0.5);

        let track = &comp.into_mixer().tracks[0];
        // 1 note + 2 chords + 1 note = 4 events
        assert_eq!(track.events.len(), 4);
    }
}
