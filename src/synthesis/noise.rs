//! Noise generators for synthesis and modulation
//!
//! This module provides various noise generators useful for:
//! - **Audio synthesis**: Percussion, textures, ambient sounds
//! - **Modulation**: Random parameter variation
//! - **Sound design**: Natural, organic timbres
//!
//! # Examples
//!
//! ```
//! use tunes::synthesis::noise::{WhiteNoise, BrownNoise};
//!
//! // Generate white noise for hi-hat sound
//! let mut white = WhiteNoise::new();
//! let samples = white.generate(1000);
//!
//! // Generate brown noise for rumble/bass texture
//! let mut brown = BrownNoise::new();
//! let bass_texture = brown.generate(1000);
//! ```

use rand::{Rng, SeedableRng};

/// Noise types available for synthesis
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum NoiseType {
    /// White noise - equal energy at all frequencies
    White,
    /// Brown noise - more low-frequency energy, random walk
    Brown,
}

impl NoiseType {
    /// Generate noise samples of this type
    ///
    /// # Arguments
    /// * `length` - Number of samples to generate
    ///
    /// # Returns
    /// Vector of samples in the range [-1.0, 1.0]
    pub fn generate(self, length: usize) -> Vec<f32> {
        match self {
            NoiseType::White => {
                let mut gen = WhiteNoise::new();
                gen.generate(length)
            }
            NoiseType::Brown => {
                let mut gen = BrownNoise::new();
                gen.generate(length)
            }
        }
    }
}

/// Trait for noise generators
///
/// This trait allows any noise generator to be used with TrackBuilder
/// and other parts of the library. Implement this trait for custom
/// noise generators.
pub trait NoiseGenerator {
    /// Generate a single sample in the range [-1.0, 1.0]
    fn sample(&mut self) -> f32;

    /// Generate multiple samples
    ///
    /// Default implementation calls `sample()` repeatedly.
    /// Override for more efficient bulk generation if needed.
    fn generate(&mut self, length: usize) -> Vec<f32> {
        (0..length).map(|_| self.sample()).collect()
    }
}

/// White noise generator - equal energy at all frequencies
///
/// White noise contains all frequencies with equal amplitude, creating
/// a "static" or "hiss" sound. It's the acoustic equivalent of white light.
///
/// # Musical Applications
/// - **Hi-hats**: Short bursts of filtered white noise
/// - **Snare drums**: Mixed with tonal components for realistic snares
/// - **Wind/rain**: Natural environmental textures
/// - **Transitions**: Noise sweeps between sections
///
/// # Example
/// ```
/// use tunes::synthesis::noise::WhiteNoise;
///
/// let mut white = WhiteNoise::new();
///
/// // Generate single samples
/// let sample1 = white.sample();
/// let sample2 = white.sample();
///
/// // Generate multiple samples at once
/// let samples = white.generate(44100); // 1 second at 44.1kHz
/// ```
#[derive(Debug)]
pub struct WhiteNoise {
    rng: rand::rngs::StdRng,
}

impl WhiteNoise {
    /// Create a new white noise generator with random seed
    pub fn new() -> Self {
        Self {
            rng: rand::rngs::StdRng::from_rng(&mut rand::rng()),
        }
    }

    /// Create a new white noise generator with a specific seed
    ///
    /// Using a seed makes the noise repeatable/deterministic.
    ///
    /// # Example
    /// ```
    /// use tunes::synthesis::noise::WhiteNoise;
    ///
    /// let mut noise1 = WhiteNoise::with_seed(12345);
    /// let mut noise2 = WhiteNoise::with_seed(12345);
    ///
    /// // Both generators produce identical output
    /// assert_eq!(noise1.sample(), noise2.sample());
    /// ```
    pub fn with_seed(seed: u64) -> Self {
        Self {
            rng: rand::rngs::StdRng::seed_from_u64(seed),
        }
    }

    /// Generate a single sample in the range [-1.0, 1.0]
    #[inline]
    pub fn sample(&mut self) -> f32 {
        self.rng.random_range(-1.0..1.0)
    }

    /// Generate multiple samples
    ///
    /// Returns a vector of `length` samples, each in the range [-1.0, 1.0].
    pub fn generate(&mut self, length: usize) -> Vec<f32> {
        (0..length).map(|_| self.sample()).collect()
    }
}

impl Default for WhiteNoise {
    fn default() -> Self {
        Self::new()
    }
}

/// Brown noise generator (Brownian motion / random walk)
///
/// Brown noise (also called red noise or Brownian noise) is generated by
/// integrating white noise, creating a random walk. This produces a sound
/// with more energy at low frequencies, making it deeper and more "rumbling"
/// than white noise.
///
/// The frequency spectrum decreases by 6dB per octave (1/fÂ²), giving it
/// a warm, bassy character.
///
/// # Musical Applications
/// - **Bass textures**: Deep, organic rumbles
/// - **Ocean sounds**: Waves, water movement
/// - **Thunder**: Low-frequency atmospheric effects
/// - **Ambient drones**: Evolving low-end foundation
///
/// # Example
/// ```
/// use tunes::synthesis::noise::BrownNoise;
///
/// let mut brown = BrownNoise::new();
///
/// // Generate single samples
/// let sample = brown.sample();
///
/// // Generate bass rumble texture
/// let rumble = brown.generate(44100); // 1 second
/// ```
#[derive(Debug)]
pub struct BrownNoise {
    current: f32,
    step_size: f32,
    rng: rand::rngs::StdRng,
}

impl BrownNoise {
    /// Create a new brown noise generator with random seed
    ///
    /// Uses a default step size of 0.05 which provides good balance
    /// between smoothness and variation.
    pub fn new() -> Self {
        Self {
            current: 0.0,
            step_size: 0.05,
            rng: rand::rngs::StdRng::from_rng(&mut rand::rng()),
        }
    }

    /// Create a new brown noise generator with a specific seed
    ///
    /// Using a seed makes the noise repeatable/deterministic.
    ///
    /// # Example
    /// ```
    /// use tunes::synthesis::noise::BrownNoise;
    ///
    /// let mut noise1 = BrownNoise::with_seed(54321);
    /// let mut noise2 = BrownNoise::with_seed(54321);
    ///
    /// // Both generators produce identical output
    /// assert_eq!(noise1.sample(), noise2.sample());
    /// ```
    pub fn with_seed(seed: u64) -> Self {
        Self {
            current: 0.0,
            step_size: 0.05,
            rng: rand::rngs::StdRng::seed_from_u64(seed),
        }
    }

    /// Create a brown noise generator with custom step size
    ///
    /// Larger step sizes create more variation but can drift faster.
    /// Smaller step sizes create smoother, slower evolution.
    ///
    /// # Arguments
    /// * `step_size` - How much the value can change per sample (typically 0.01 - 0.1)
    ///
    /// # Example
    /// ```
    /// use tunes::synthesis::noise::BrownNoise;
    ///
    /// // Slower, smoother brown noise
    /// let mut smooth = BrownNoise::with_step_size(0.01);
    ///
    /// // Faster, more chaotic brown noise
    /// let mut rough = BrownNoise::with_step_size(0.1);
    /// ```
    pub fn with_step_size(step_size: f32) -> Self {
        Self {
            current: 0.0,
            step_size,
            rng: rand::rngs::StdRng::from_rng(&mut rand::rng()),
        }
    }

    /// Generate a single sample in the range [-1.0, 1.0]
    ///
    /// Uses a random walk: current value changes by a small random amount
    /// each sample, with clamping to keep output in valid range.
    #[inline]
    pub fn sample(&mut self) -> f32 {
        // Take a random step
        let delta = self.rng.random_range(-self.step_size..self.step_size);
        self.current += delta;

        // Clamp to prevent drift beyond [-1, 1]
        // Use soft clamping: reflect at boundaries for smoother behavior
        if self.current > 1.0 {
            self.current = 2.0 - self.current; // Reflect
        } else if self.current < -1.0 {
            self.current = -2.0 - self.current; // Reflect
        }

        // Additional hard clamp for safety
        self.current = self.current.clamp(-1.0, 1.0);

        self.current
    }

    /// Generate multiple samples
    ///
    /// Returns a vector of `length` samples, each in the range [-1.0, 1.0].
    pub fn generate(&mut self, length: usize) -> Vec<f32> {
        (0..length).map(|_| self.sample()).collect()
    }

    /// Reset the internal state to zero
    ///
    /// Useful if you want to restart the random walk from the center.
    pub fn reset(&mut self) {
        self.current = 0.0;
    }
}

impl Default for BrownNoise {
    fn default() -> Self {
        Self::new()
    }
}

// Implement NoiseGenerator trait for built-in noise types
impl NoiseGenerator for WhiteNoise {
    fn sample(&mut self) -> f32 {
        WhiteNoise::sample(self)
    }

    fn generate(&mut self, length: usize) -> Vec<f32> {
        WhiteNoise::generate(self, length)
    }
}

impl NoiseGenerator for BrownNoise {
    fn sample(&mut self) -> f32 {
        BrownNoise::sample(self)
    }

    fn generate(&mut self, length: usize) -> Vec<f32> {
        BrownNoise::generate(self, length)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_white_noise_range() {
        let mut white = WhiteNoise::new();

        // Generate 1000 samples and verify all are in valid range
        for _ in 0..1000 {
            let sample = white.sample();
            assert!(
                sample >= -1.0 && sample <= 1.0,
                "White noise sample {} out of range",
                sample
            );
        }
    }

    #[test]
    fn test_white_noise_is_random() {
        let mut white = WhiteNoise::new();

        // Generate samples and verify they're not all the same
        let samples: Vec<f32> = (0..100).map(|_| white.sample()).collect();

        // Check that we have variation (not all samples identical)
        let first = samples[0];
        let has_variation = samples.iter().any(|&s| (s - first).abs() > 0.1);
        assert!(has_variation, "White noise should have variation");
    }

    #[test]
    fn test_white_noise_seeded_deterministic() {
        let mut noise1 = WhiteNoise::with_seed(12345);
        let mut noise2 = WhiteNoise::with_seed(12345);

        // Same seed should produce identical output
        for _ in 0..100 {
            assert_eq!(
                noise1.sample(),
                noise2.sample(),
                "Seeded white noise should be deterministic"
            );
        }
    }

    #[test]
    fn test_white_noise_generate() {
        let mut white = WhiteNoise::new();
        let samples = white.generate(500);

        assert_eq!(samples.len(), 500);

        // All samples should be in valid range
        for &sample in &samples {
            assert!(sample >= -1.0 && sample <= 1.0);
        }
    }

    #[test]
    fn test_brown_noise_range() {
        let mut brown = BrownNoise::new();

        // Generate 10000 samples to test clamping under stress
        for i in 0..10000 {
            let sample = brown.sample();
            assert!(
                sample >= -1.0 && sample <= 1.0,
                "Brown noise sample {} out of range at iteration {}",
                sample,
                i
            );
        }
    }

    #[test]
    fn test_brown_noise_continuity() {
        let mut brown = BrownNoise::new();

        // Brown noise should be continuous (adjacent samples close together)
        let mut prev = brown.sample();

        for _ in 0..100 {
            let current = brown.sample();

            // Adjacent samples shouldn't differ by more than step_size
            let diff = (current - prev).abs();
            assert!(
                diff <= 0.1, // step_size default is 0.05, but with reflection can be slightly more
                "Brown noise discontinuity: {} to {} (diff: {})",
                prev,
                current,
                diff
            );

            prev = current;
        }
    }

    #[test]
    fn test_brown_noise_seeded_deterministic() {
        let mut noise1 = BrownNoise::with_seed(54321);
        let mut noise2 = BrownNoise::with_seed(54321);

        // Same seed should produce identical output
        for _ in 0..100 {
            assert_eq!(
                noise1.sample(),
                noise2.sample(),
                "Seeded brown noise should be deterministic"
            );
        }
    }

    #[test]
    fn test_brown_noise_reset() {
        let mut brown = BrownNoise::new();

        // Generate some samples to move away from zero
        for _ in 0..100 {
            brown.sample();
        }

        // Reset should return to zero
        brown.reset();
        assert_eq!(brown.current, 0.0, "Reset should set current to 0");
    }

    #[test]
    fn test_brown_noise_step_size() {
        let mut smooth = BrownNoise::with_step_size(0.01);
        let mut rough = BrownNoise::with_step_size(0.1);

        // Smooth should have smaller variations
        let smooth_samples = smooth.generate(100);
        let rough_samples = rough.generate(100);

        // Calculate variance
        let smooth_variance = calculate_variance(&smooth_samples);
        let rough_variance = calculate_variance(&rough_samples);

        // Rough should generally have more variance
        // (This is probabilistic, but with 100 samples should be reliable)
        assert!(
            rough_variance > smooth_variance * 0.5,
            "Larger step size should create more variance"
        );
    }

    #[test]
    fn test_brown_noise_generate() {
        let mut brown = BrownNoise::new();
        let samples = brown.generate(500);

        assert_eq!(samples.len(), 500);

        // All samples should be in valid range
        for &sample in &samples {
            assert!(sample >= -1.0 && sample <= 1.0);
        }
    }

    #[test]
    fn test_brown_noise_low_frequency_bias() {
        // Use seeded generator for deterministic test
        let mut brown = BrownNoise::with_seed(42);
        // Generate more samples for stable statistics
        let samples = brown.generate(10000);

        // Brown noise should be more "smooth" than white noise
        // Check that adjacent samples are correlated
        let mut correlation_sum = 0.0;
        for i in 0..samples.len() - 1 {
            correlation_sum += samples[i] * samples[i + 1];
        }
        let avg_correlation = correlation_sum / (samples.len() - 1) as f32;

        // Adjacent samples should be positively correlated (smooth evolution)
        // White noise would have near-zero correlation
        // With 10k samples and seed 42, correlation should be strong and stable
        assert!(
            avg_correlation.abs() > 0.05,
            "Brown noise should show adjacent sample correlation, got: {}",
            avg_correlation
        );
    }

    // Helper function for variance calculation
    fn calculate_variance(samples: &[f32]) -> f32 {
        let mean: f32 = samples.iter().sum::<f32>() / samples.len() as f32;
        let variance: f32 = samples
            .iter()
            .map(|&x| {
                let diff = x - mean;
                diff * diff
            })
            .sum::<f32>()
            / samples.len() as f32;
        variance
    }
}
